using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using UI;
using UnityEditor;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

namespace CometUI
{
    static class ScriptBuilder
    {
        static Templates templates;

        static Template GetTemplate(string name) => templates.GetTemplate(name);

        public static void CreateUserScript(ViewNode node, bool replaceIfExists)
        {
            var rn = Environment.NewLine;

            LoadTemplates();

            //get list of UI controls (not views and not Buttons)
            var selectables = node.ViewInfo.Members.Values.Where(m => m.Component is Selectable sel && !(sel is Button));

            //get template
            var res = GetTemplate("ViewClassUser");
            if (selectables.Any())
                res.Add("#METHODS#", GetTemplate("OnChanged").ToString());

            //prepare Set methods in OnBuild
            //get list of UI controls (not views and not Buttons)
            var controls = node.ViewInfo.Members.Values.Where(m => m.Component != null && !(m.Component is Button));

            foreach (var sel in controls)
                res.Add("#OnBuildBody#", $"            //Set({sel.Name}, default);");

            var view = node.rt.GetComponent<BaseView>();
            if (view != null && !string.IsNullOrWhiteSpace(view.SignatureOfBuildMethod))
                res.Add("#ALLOWEDDATA#", $"//Data: {view.SignatureOfBuildMethod}");

            //prepare Subscribe methods in Start
            //get list of buttons w/o bindings
            var buttons = node.ViewInfo.Members.Values.Where(m => (m.Component is Button) && !node.Outputs.Any(p=>p.ValueType == typeof(ActionOutputPort) && p.fieldName == m.Name));

            foreach (var bt in buttons)
                res.Add("#StartBody#", $"            Subscribe({bt.Name}, () => {{;}});");

            //replace class name
            res.Add("#CLASSNAME#", node.name);
            res.Add("#SCENENAME#", GetSceneName(node.rt.gameObject.scene));

            //save
            CreateNeededFolders(node.rt.gameObject.scene);

            var filePath = Path.Combine(ScriptsFolder, node.name + ".cs");
            if (!File.Exists(filePath) || replaceIfExists)
            {
                var scriptText = CSharpPreparer.Prepare(res.ToString());
                File.WriteAllText(filePath, scriptText);
                AssetDatabase.Refresh();
            }
        }

        public static void CreateScripts(UIGraph graph)
        {
            var firstNode = graph.nodes.OfType<ViewNode>().FirstOrDefault();
            if (firstNode == null)
                return;

            CreateNeededFolders(firstNode.rt.gameObject.scene);
            LoadTemplates();

            foreach (var node in graph.nodes.OfType<ViewNode>())
                try
                {
                    CreateScript(node, false);
                }catch(Exception ex)
                {
                    Debug.LogError(ex);
                }

            //create localization file
            Localization.CreateLocalizationFile();

            Debug.Log("CometUI: Build completed.");

            AssetDatabase.Refresh();
        }

        public static string GetSceneName(Scene scene)
        {
            var res = scene.name.Replace(" ", "");
            return res;
        }

        public static void CreateScript(ViewNode node, bool loadTemplates = true)
        {
            if (node.rt == null)
                return;

            if (loadTemplates)
                LoadTemplates();

            var rn = Environment.NewLine;
            var res = GetTemplate("ViewClass");
            var fieldsTemplate = GetTemplate("Fields");
            var sceneName = GetSceneName(node.rt.gameObject.scene);

            node.GrabInfoAboutView(node.rt);

            if (node.ViewInfo == null)
                return;

            var view = node.rt.GetComponent<BaseView>();
            bool wasFields = false;

            //fields
            foreach (var item in node.ViewInfo.Members.Values)
            {
                if (item.Type == node.name)
                    continue;//myself
                if ((item.FieldInfo != null && item.IsAutogenerated) ||
                    (item.Binded != null && item.IsAutogenerated) ||
                    (item.Component != null))
                {
                    wasFields = true;
                    fieldsTemplate.Add("#FIELDS#", $"[AutoGenerated, SerializeField, HideInInspector] {item.Type} {item.Name} = default;");
                    res.Add("#INIT#", $"SubscribeOnChanged({item.Name});");
                }
            }

            //links
            foreach (var port in node.Outputs.Where(p=>p.ValueType == typeof(ActionOutputPort) || p.ValueType == typeof(GesturePort) || p.ValueType == typeof(EventPort)))
            {
                foreach (var linked in port.GetConnections())
                {
                    //arg
                    var arg = "";
                    if (linked.fieldName == nameof(BaseView.Show) ||
                        linked.fieldName == nameof(BaseView.ShowOrClose) ||
                        linked.fieldName == nameof(BaseView.Reopen) ||
                        linked.fieldName == nameof(BaseView.ReopenAnimated) ||
                        linked.fieldName == nameof(BaseView.BuildAndShow))
                        arg = nameof(BaseView.OwnerForChild);

                    //obj name
                    var objName = linked.node.name;

                    if (linked.node.name == node.name)
                        objName = "this";

                    if (linked.node is GlobalNode)
                        objName = nameof(UIManager);

                    //my name
                    var myName = port.fieldName;
                    if (port.ValueType == typeof(GesturePort))
                        myName = nameof(Gesture) + "." + myName;

                    //is event?
                    if (port.ValueType == typeof(EventPort))
                    {
                        //subscribe event
                        res.Add("#INIT#", $"{myName} += {objName}.{linked.fieldName};");
                    }else
                    {
                        //subscribe
                        res.Add("#INIT#", $"Subscribe({myName}, () => {objName}.{linked.fieldName}({arg}));");
                    }
                }
            }

            //method Build
            var signature = view == null ? "" : view.SignatureOfBuildMethod;
            CreateBuildMethod(node.name, signature, res);

            //prepare
            if (wasFields)
                res.Add("#FIELDS#", fieldsTemplate.ToString());

            //replace class name
            res.Add("#CLASSNAME#", node.name);
            res.Add("#SCENENAME#", sceneName);

            //save
            CreateNeededFolders(node.rt.gameObject.scene);

            var filePath = Path.Combine(AutoScriptsFolder, node.name + ".cs");
            var scriptText = CSharpPreparer.Prepare(res.ToString());
            File.WriteAllText(filePath, scriptText);

            if (loadTemplates)
                AssetDatabase.Refresh();
        }

        private static void CreateBuildMethod(string className, string signature, Template template)
        {
            var args = Argument.Parse(signature).ToArray();

            foreach (var arg in args)
            if(!arg.CheckIsTypeExists())
            {
                //if (EditorUtility.DisplayDialog("Error", "Unknown type in Build signature: " + arg.Type + $"\r\nIn view {className}.", "Do not create script", "Ignore"))
                //    throw new Exception("Unknown type in Build signature: " + arg.Type);
            }

            var rn = args.Length > 0 ? Environment.NewLine : "";
            var summary = args.Length > 0 ? "    ///<summary>Data</summary>" + rn : "";

            template.Add("#BUILDFIELDS#", summary + string.Join(rn, args.Select(a => $"    public {a.Type} {a.Name}{{ get; private set; }}")) + rn);
            template.Add("#BUILDSIGNATURE#", signature);
            template.Add("#BUILDBODY#", string.Join(rn, args.Select(a => $"        this.{a.Name} = {a.Name};")) + rn);

            //clone method
            if (args.Length > 0)
            {
                var cloneTemplate = GetTemplate("Clone");
                cloneTemplate.Add("#CLASSNAME#", className);
                cloneTemplate.Add("#COPYFIELDS#", string.Join(rn, args.Select(a => $"        clone.{a.Name} = {a.Name};")) + rn);
                template.Add("#CLONE#", rn + cloneTemplate);
            }
        }

        private static void LoadTemplates()
        {
            var textAsset = Resources.Load<TextAsset>("CometUI_Templates");
            var text = textAsset.text;
            templates = Templates.Parse(text);
        }

        private static void CreateNeededFolders(Scene scene)
        {
            if (string.IsNullOrEmpty(scene.path))
                throw new Exception("Scene is not saved!");

            //
            AutoScriptsFolder = GetAutogeneratedScriptFolder(scene);
            ScriptsFolder = Path.GetDirectoryName(AutoScriptsFolder);

            if (!Directory.Exists(ScriptsFolder))
                Directory.CreateDirectory(ScriptsFolder);
            if (!Directory.Exists(AutoScriptsFolder))
                Directory.CreateDirectory(AutoScriptsFolder);
        }

        public static string GetAutogeneratedScriptFolder(Scene scene)
        {
            //
            var dir = GetScriptsFolder(scene);
            var autoScriptsFolder = Path.Combine(dir, "_autogenerated");
            return autoScriptsFolder;
        }

        public static string GetFolderRelativeToRoot(string dir)
        {
            var prefix = Path.GetDirectoryName(Application.dataPath) + Path.DirectorySeparatorChar;
            if (dir.StartsWith(prefix))
                dir = dir.Substring(prefix.Length);
            else
                throw new Exception("Can not find root dir");

            return dir;
        }

        static string AutoScriptsFolder;
        static string ScriptsFolder;

        public static string GetScriptsFolder(Scene scene)
        {
            var assetFolder = Application.dataPath;
            assetFolder = Path.GetDirectoryName(assetFolder);

            var dir = Path.Combine(assetFolder, Path.GetDirectoryName(scene.path));
            dir = Path.Combine(dir, GetSceneName(scene) + "_Scripts");

            return dir;
        }
    }

    public class Argument
    {
        public string Type;
        public string Name;
        public string DefaultValue;

        public static IEnumerable<Argument> Parse(string signature)
        {
            if (string.IsNullOrWhiteSpace(signature))
                yield break;

            var parts = (signature ?? "").Split(',');
            foreach (var part in parts)
            {
                var parts2 = part.Trim().Split('=');
                var parts3 = parts2[0].Trim().Split(' ');
                string defaultVal = null;
                if (parts2.Length > 1)
                    defaultVal = parts2[1].Trim();

                if (parts3.Length == 2)
                    yield return new Argument { Name = parts3[1], Type = parts3[0], DefaultValue = defaultVal };
            }
        }

        static HashSet<string> wellKnownTypes = new HashSet<string>();

        static Argument()
        {
            GrabTypes(typeof(string).Assembly);
            GrabTypes(typeof(Vector2).Assembly);

            wellKnownTypes.Add("string");
            wellKnownTypes.Add("int");
            wellKnownTypes.Add("float");
            wellKnownTypes.Add("double");
            wellKnownTypes.Add("byte");
            wellKnownTypes.Add("decimal");
            wellKnownTypes.Add("char");
            wellKnownTypes.Add("bool");
        }

        static void GrabTypes(Assembly ass)
        {
            foreach (var type in ass.GetTypes().Select(t => t.Name.ToLower()))
                wellKnownTypes.Add(type);
        }

        public bool CheckIsTypeExists()
        {
            var parts = Type.Split('.');
            var lastPart = parts[parts.Length - 1].ToLower();
            var bracketIndex = lastPart.IndexOf('[');
            if (bracketIndex >= 0)
                lastPart = lastPart.Substring(0, bracketIndex);

            if (wellKnownTypes.Contains(lastPart))
                return true;

            //if (typeof(string).Assembly.GetType(Type) != null)
            //    return true;
            //if (typeof(Vector2).Assembly.GetType(Type) != null)
            //    return true;
            if (UIGraphEditor.GetTypeByName(Type, "") != null)
                return true;
            return false;
        }
    }
}
